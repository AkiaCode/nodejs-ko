---
layout: post
title: io.js 의 v2.0 이 나왔습니다.
author: Yosuke FURUKAWA
ref: io.js の v2.0 が出ました。
refurl: http://yosuke-furukawa.hatenablog.com/entry/2015/05/06/170034
translator:
- <a href="https://github.com/asbubam" target="_blank">asbubam</a>
---

<!--
https://hexi.pics/resize/w/462/h/462/e03baa40377a8e562cb376199c6e3721.png
さてさて、久しぶりのio.js エントリですが、この度 io.js の v2.0 が出ました。
変更点をかいつまんで説明しましょう。書いてたら長くなってしまったので、サマリだけでいい人は最後のまとめを読むだけでいいと思います。

io.js は変化がものすごく激しく、v1.0 から v2.0 が入るまでに色んな機能が入っているんですが、知らない人も多いかと思います。

今回は v2.0 の単なる変更点だけじゃなくて、 v1.0 から今までで入った機能をサマリつつ伝えていこうかと思います。
-->

![io.js logo](https://hexi.pics/resize/w/462/h/462/e03baa40377a8e562cb376199c6e3721.png)

참, 오래간만의 io.js 항목의 글입니다만, 이번에 io.js 의 v2.0 이 나왔습니다.
변경사항을 간추려서 설명하겠습니다. 쓰다보니 길어졌기 때문에, 요약된 부분만 읽고 싶은분은 마지막의 결론을 읽는 것으로 충분하다고 생각합니다.

io.js는 변화가 워낙 많은편이라, v1.0에서 v2.0으로 되면서 여러 기능이 추가되고 있는데, 모르는 사람도 많을 것으로 생각됩니다. 

이번에는 v2.0의 단순한 변경 사항 뿐만 아니라, v1.0부터 지금까지 추가된 기능을 정리하면서 전달해보려고 합니다.

<!--
Stream Simpler Construction (v1.2.0〜)

Stream の作成が簡単になりました。今までStreamを作るためには、目的のStreamを継承して、TransformStreamであれば _transform のようなメソッドを拡張して実現する必要がありました。

これをより簡単にしたものが through2 に代表されるヘルパライブラリでしたが、簡単にいえばこの through2 がなくても io.js では Stream を作るのが簡単にできるようになりました。

StreamのTransformに対して、transformやflushを取ることができ、これを使うとわざわざ継承をしなくてもTransform Streamを作ることが可能です。下記のようになりました。
-->

Stream Simpler Construction (v1.2.0〜)
----
Stream의 작성이 간단해졌습니다. 지금까지 Stream을 만들기 위해서는, 목적의 Stream을 상속해서 TransformStream 이라면 _transform과 같은 메소드를 확장해서 구현할 필요가 있었습니다. 

이를 더 간단히 변화시킨 것이, through2로 대표되는 헬퍼 라이브러리였습니다만, 간단하게 말하면 이 through2 가 없어도 io.js 에서는 Stream 을 생성하는 것이 간단하게 가능하게 되었습니다.

Stream의 Transform에 대해, transform이나 flush를 획득할 수 있고, 이것을 사용하면 일부러 상속을 하지 않아도 Transform Stream을 생성하는 것이 가능합니다. 아래와 같이 변경되었습니다.

<!--
before

var Transform = require('stream').Transform;
var util = require('util');

util.inherits(MyTransform, Transform);

function MyTransform(opts){
    Transform.call(this, opts);
}

MyTransform.prototype._transform = function(chunk, encoding, callback){
  // ここで 変換して
  ...
  // pushする
  this.push(chunk);
};

MyTransform.prototype._flush = function(done){
  // 最後に何かしたければここで flush する
};
after

var transform = new stream.Transform({
  transform: function(chunk, encoding, next) {
    // ここで 変換して
    
    ...
    // pushする
    this.push(chunk);
  },
  flush: function(done) {
    // 最後に何かしたければここで flush する
  }
});
-->

**before**
~~~javascript
javascript
var Transform = require('stream').Transform;
var util = require('util');

util.inherits(MyTransform, Transform);

function MyTransform(opts){
    Transform.call(this, opts);
}

MyTransform.prototype._transform = function(chunk, encoding, callback){
  // 여기에서 변환하고
  ...
  // push 합니다.
  this.push(chunk);
};

MyTransform.prototype._flush = function(done){
  // 마지막에 무언가 하고싶다면 여기서 flush 합니다.
}
~~~

**after**
~~~javascript
var transform = new stream.Transform({
  transform: function(chunk, encoding, next) {
    // 여기에서 변환하고
    ...
    // push 합니다.
    this.push(chunk);
  },
  flush: function(done) {
    // 마지막에 무언가 하고 싶다면 여기서 flush 합니다.
  }
});
~~~

<!--
ここでは Transform Stream で例を示しましたが、 Readable や Writable も簡単に作れるようになりました。
詳しくはコチラを見てください。
https://iojs.org/api/stream.html#stream_simplified_constructor_api
-->

여기서는 Transform Stream 을 예로 제시했지만, Readable 이나 Writable 도 간단히 생성할 수 있게 되었습니다.

자세한 내용은 이 링크를 참조하세요.
[https://iojs.org/api/stream.html#stream_simplified_constructor_api](https://iojs.org/api/stream.html#stream_simplified_constructor_api)

<!--
LTTNG サポート (v1.2.0〜)

HTTP のリクエストやサーバのレスポンス、GCの実行といった時にカーネルのレベルで何が起きているかを追うための機能が追加されています。今までの Node.js ではこれを行うのに Dtrace を使っていましたが、LinuxのDtrace実装は若く、全てが実装されているわけではありませんでした。結果として、 Joyentが提供している SmartOS等のSolarisをベースにしたUnix環境でしかNode.jsでDtraceを使うのはサポートされていませんでした。

これからは Linux カーネルでも標準でトレース可能な LTTNG も使えるようになりました。
詳しくはここを見てもらえるといいかと。

Node LTTNG
-->

LTTNG 서포트 (v1.2.0~)
----
HTTP의 Request 혹은 서버의 Response, GC가 실행될 때 커널레벨에서 어떤일이 벌어지는 지를 추적하기 위한 기능이 추가되었습니다. 지금까지의 Node.js 에서는 이것을 실행하기 위해서 Dtrace를 사용해 왔습니다만, Linux의 Dtrace구현은 미숙해서, 모두 장착되어 있는 것이 아니었습니다. 결과적으로, Joyent가 제공하고 있는 SmartOS등의 Solaris를 베이스로한 Unix환경에서만 Node.js에서 Dtrace를 사용하는 것이 서포트 되고 있었습니다.

이제는 Linux 커널에서도 표준으로 트레이스가 가능한 LTTNG 도 사용할 수 있게 되었습니다.

자세한 설명은 이 링크를 보시면 좋겠다고 생각합니다.

[Node LTTNG](http://nearform.github.io/tracing-node-lttng-nodejsdublin/)

![](http://nearform.github.io/tracing-node-lttng-nodejsdublin/pictures/demo.gif)

<!--
Promise の unhandledRejection / rejectionHandled イベント (v1.4.1〜)

Promise の catch を忘れた時に、 キャッチされていない例外として、 unhandledRejection と rejected 済みでもう呼ばれることがない例外を検出するための仕組みとして、 新しくrejectionHandledイベントが追加されました。

こちら、 azuさんの資料が詳しいので抜粋させてもらいます。

var bluebird = require("bluebird");
// unhandledRejection catchされていない例外
process.on("unhandledRejection", function (reason, promise) {
    console.log("unhandledRejection");
});

var resolved = bluebird.resolve();
resolved.then(function () {
    throw new Error("Yay!");
});
var Promise = require("bluebird");
process.on("rejectionHandled", function (promise) {
    console.log("rejectionHandled");
});
var rejected = Promise.reject(new Error("Error Promise"));
setTimeout(function () {
    rejected.catch(function () {
        // rejected済みのpromiseに`catch`する
    });
},100);
Promise Error Handling
-->

Promise 의 unhandleRejection / rejectionHandled 이벤트 (v1.4.1~)
----
Promise 의 catch 를 잊었을 때, 캐치되지 않은 예외로서, unhandleRejection 과 rejected종결로 다시 불리는 것이 없는 예외를 검출하기 위한 구조로서 새로운 rejectionHandled이벤트가 추가되었습니다.

여기 잘 설명된 azu님의 예제를 발췌하도록 하겠습니다.

~~~javascript
var bluebird = require("bluebird");
// unhandledRejection catchされていない例外
process.on("unhandledRejection", function (reason, promise) {
    console.log("unhandledRejection");
});

var resolved = bluebird.resolve();
resolved.then(function () {
    throw new Error("Yay!");
});
~~~

~~~javascript
var Promise = require("bluebird");
process.on("rejectionHandled", function (promise) {
    console.log("rejectionHandled");
});
var rejected = Promise.reject(new Error("Error Promise"));
setTimeout(function () {
    rejected.catch(function () {
        // rejected済みのpromiseに`catch`する
    });
},100);
~~~
[Promise Error Handling](http://azu.github.io/slide/error-handling/promise-error-handling.html)


<!--
Buffer に indexOf メソッドが追加されました。 (v1.5.0 〜)

Buffer に対して indexOf メソッドを使えるようになりました。これまでは 一旦 String にしたりしてから、中身の文字列を検索する必要がありましたが、その必要がなくなりました。

before

var fs = require('fs');

// ./foo.txt => yosuke furukawa
fs.readFile(__dirname + '/foo.txt', function(err, buf){
  var str = buf.toString();
  console.log(str.indexOf('furukawa')); // 7
});
after

var fs = require('fs');

// ./foo.txt => yosuke furukawa
fs.readFile(__dirname + '/foo.txt', function(err, buf){
  console.log(buf.indexOf('furukawa')); // 7
});

詳しくはコチラ。

https://iojs.org/api/buffer.html#buffer_buf_indexof_value_byteoffset
-->

Buffer 에 indexOf 메소드가 추가되었습니다. (v1.5.0 ~)

Buffer 에 대해 indexOf 메소드를 사용할 수 있게 되었습니다. 지금까지는 일단 String 으로 변환하거나해서, 

<!--
node のコマンドに --require オプションで preload モジュールを渡せるようになりました。 (v1.6.0〜)

$ node --require ./a.js b.js
事前にpreloadしておきたい場合に使えます。

process.nextTick に複数の引数を渡せるようになりました。 (v1.8.0〜)

var obj = {};

process.nextTick(function(a, b) {
  assert.equal(a, 42);
  assert.equal(b, obj);
}, 42, obj);
この変更によって、process.nextTick の callback に任意の引数を渡すことができるようになりました。
APIが setTimeoutやsetIntervalと似るようになりました。

REPL に history save 機能が追加 (v2.0〜)

REPL の magic mode と呼ばれる機能が追加されています。これは、環境引数NODE_REPL_HISTORY_FILEを指定することでREPLを終了させても、次回の起動時に自分が実行したreplの内容を記憶してくれる機能です。いわゆる、 REPL の history save 機能ですね。

$ NODE_REPL_HISTORY_FILE=~/.node_history iojs
> var fs = require('fs');
> fs.readFile;
# Ctrl-D


$ NODE_REPL_HISTORY_FILE=~/.node_history iojs
> # push up button
> fs.readFile;
これは NODE_REPL_HISTORY_FILEを指定しないといけなくて、必ず有効にはなりません。
僕は .zshrc に以下のように書くことで対応しています。

# iojs
alias iojs-repl="NODE_REPL_HISTORY_SIZE=Infinity NODE_REPL_HISTORY_FILE=~/.node_history iojs"
こうするとiojs-replで実行するときにはhistoryが有効になります。

詳しくはコチラ
https://iojs.org/api/repl.html#repl_repl

ES6でデフォルトで使える構文が追加 (v2.0〜)

僕が少し前に作ったiojsの新機能紹介リポジトリにも書きましたが、日本語で説明を加えていきます。

class

クラスがデフォルトで使えるようになりました。

// strict mode needed
'use strict';

class Animal {
  constructor(name) {
    this.name = name
  }

  say() {
    // unimplemented
  }
}

class Cat extends Animal {
  say() {
    console.log(`${this.name} < meow`);
  }
}

var cat = new Cat('Mike');
cat.say(); // Mike < meow
これはかなり重要で、 io.js v2.0 を使っている分には util.inherits のような継承のためのヘルパメソッドは不要になるし、ビルドインクラスを継承するのにも使えます。
enhanced object literals (v2.0〜)

Object のリテラルに拡張が加わりました。 以下のように key と value が一緒の時は省略して記述することができるようになります。

'use strict';
// class
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
 getInfo() {
    let name = this.name;
    let age = this.age;
    let nextAge = this.age + 1;
    // enhanced object literal
    return {
      name,
      age,
      nextAge
    };
  }
}

var bob = new Person('bob', 15);

console.log(bob.getInfo()); // { name: 'bob', age: 15, nextAge: 16 }
Rest パラメータが --harmony-rest-parameters オプション付きで有効になりました。

harmony option 付きで Rest パラメータが追加されました。

// Rest parameters
function max(...args) {
  // rest parameter is not Array-like object, that is just array.
  console.log(Array.isArray(args))  // true
  console.log(args.length)          // 6

  var max = args.reduce(function(max, n) { 
    return n > max ? n : max;
  });
  return max;
}

var maxNum = max(5, 15, 10, 1, 4, 5);
console.log(maxNum); // 15
実行するには下記のようにします。

$ iojs --harmony-rest-parameters es6/rest_params/rest.js
Computed property names が --harmony-computed-property-names オプション付きで有効になりました。

harmony オプション付きで、Computed property names が使えるようになりました。

var i = 0;
var a = {
  ["foo" + ++i]: i,
  ["foo" + ++i]: i,
  ["foo" + ++i]: i
};

console.log(a.foo1); // 1
console.log(a.foo2); // 2
console.log(a.foo3); // 3

var param = 'size';
var config = {
  [param]: 12,
  ["mobile" + param.charAt(0).toUpperCase() + param.slice(1)]: 4
};

console.log(config);
以下のように実行します。

$ iojs --harmony-computed-property-names es6/computed_property/computedProps.js
Strong mode がサポートされました。 (v2.0〜)

今、 Google の v8 チームは色んな試みをしているのですが、 StrongScriptと呼ばれる試みをしています。
これは、JavaScriptの自由度の高い構文 (var, arguments, ==, delete, for-in 等)をなるべく deprecated にして、ES6 を含めた最新の構文(let, ...args, ===, Map, for-of)に書き換えるための試みです。

この StrongScript は コードの先頭に 'use strong' ディレクティブを付けることで Strong Mode になり、実行されます。
ちょうど 'use strict' で Strict Mode にするのと同様です。

今回のio.js v2.0 からこの Strong Mode が --strong_mode オプション付きで使えるようになりました。

※ ちなみにまだまだ実験的な試みなので、本番環境で使うのは推奨できません。

var => let/const

'use strong';

var a = 'hoge';
$ iojs --strong_mode strong_mode/vars.js

/Users/yosuke/iojs_v2_features/strong_mode/vars.js:3
var a = 'hoge';
^^^
SyntaxError: Please don't use 'var' in strong mode, use 'let' or 'const' instead
    at exports.runInThisContext (vm.js:53:16)
    at Module._compile (module.js:411:25)
    at Object.Module._extensions..js (module.js:446:10)
    at Module.load (module.js:353:32)
    at Function.Module._load (module.js:308:12)
    at Function.Module.runMain (module.js:469:10)
    at startup (node.js:124:18)
    at node.js:882:3
arguments => ...args

'use strong';

function some() {
  let args = Array.prototype.slice.call(arguments);
}

some();
$ iojs --strong_mode strong_mode/arguments.js
/Users/yosuke/iojs_v2_features/strong_mode/arguments.js:4
  let args = Array.prototype.slice.call(arguments);
                                        ^^^^^^^^^
SyntaxError: Please don't use 'arguments' in strong mode, use '...args' instead
    at exports.runInThisContext (vm.js:53:16)
    at Module._compile (module.js:411:25)
    at Object.Module._extensions..js (module.js:446:10)
    at Module.load (module.js:353:32)
    at Function.Module._load (module.js:308:12)
    at Function.Module.runMain (module.js:469:10)
    at startup (node.js:124:18)
    at node.js:882:3
eqeq => eqeqeq

'use strong';

if ('a' == 'a') {
}
$ iojs --strong_mode strong_mode/eqeq.js

/Users/yosuke/iojs_v2_features/strong_mode/eqeq.js:3
if ('a' == 'a') {
        ^^
SyntaxError: Please don't use '==' or '!=' in strong mode, use '===' or '!==' instead
    at exports.runInThisContext (vm.js:53:16)
    at Module._compile (module.js:411:25)
    at Object.Module._extensions..js (module.js:446:10)
    at Module.load (module.js:353:32)
    at Function.Module._load (module.js:308:12)
    at Function.Module.runMain (module.js:469:10)
    at startup (node.js:124:18)
    at node.js:882:3
propertyの削除に対して、 delete を使わず、 Map/Setを使う

'use strong';
let obj = { key: 'value'};
delete obj.key;
console.log(obj);
$ iojs --strong_mode strong_mode/delete.js
/Users/yosuke/iojs_v2_features/strong_mode/delete.js:5
delete obj.key;
           ^^^
SyntaxError: Please don't use 'delete' in strong mode, use maps or sets instead
    at exports.runInThisContext (vm.js:53:16)
    at Module._compile (module.js:411:25)
    at Object.Module._extensions..js (module.js:446:10)
    at Module.load (module.js:353:32)
    at Function.Module._load (module.js:308:12)
    at Function.Module.runMain (module.js:469:10)
    at startup (node.js:124:18)
    at node.js:882:3
for-in => for-of

'use strong';

for (let k in [1, 2, 3]) {
  console.log(k);
}
$ iojs --strong_mode strong_mode/for.js
/Users/yosuke/iojs_v2_features/strong_mode/for.js:3
for (let k in [1, 2, 3]) {
           ^^
SyntaxError: Please don't use 'for'-'in' loops in strong mode, use 'for'-'of' instead
    at exports.runInThisContext (vm.js:53:16)
    at Module._compile (module.js:411:25)
    at Object.Module._extensions..js (module.js:446:10)
    at Module.load (module.js:353:32)
    at Function.Module._load (module.js:308:12)
    at Function.Module.runMain (module.js:469:10)
    at startup (node.js:124:18)
    at node.js:882:3
幅広い環境のサポート (v1.4.0, v1.6.0, v1.8.0 )

今回、かなりビルド環境に気合が入っていて、幅広い環境でバイナリが提供されています。 Node.js の時は、 darwin(osx), linux, sunos(solaris), windows のバイナリが提供されるだけでしたが(それでもかなり素晴らしいけど)、 io.js からは ARM v6, v7も含めたかなり多くの環境でバイナリが提供されています。

binaryは提供されていませんが、 Android でも動くためのビルドオプションがあったり、SmartOS、FreeBSDでも動くためのオプションが提供されています。

また色んなOSの仮想環境を構築し、そこの上でテストを実行しています。どこかの環境でエラーがあったらすぐに分かるようになっています。

https://jenkins-iojs.nodesource.com/job/iojs+any-pr+multi/
依存ライブラリ関連 (v2.0.0〜)

v8が 4.2 になった

v8が新しくなったので、JavaScriptの最適化やES6の機能が増えました。これに関しては先ほど紹介しました。
また、v8がアップグレードされたことで、V8のAPI が更新され、 Native Module も変更が必要になりました。
つまり、古いNative moduleのままでは動かなくなってしまいました。

現時点で v2.0 では動かないモジュール一覧に関しては以下のissueをご一読ください。

github.com

nan の更新を行うだけでいけるモジュールも多いので、忘れているモジュールに関しては、 今のところ nan を更新して pull request で教えてあげればいいかと思います。
ただ毎回 v8 が更新されるだけで動かなくなるモジュールがたくさんあると困るので、 nan を core に入れる提案もされています。

OpenSSL v1.0.2a になった

OpenSSL が v1.0.2a になり、 crypto の性能が改善されました。
この辺りの記事が詳しいです。*1

github.com
http-parser v2.5.0 になった

http-parserがやっと最新になりました。一旦 http-parser は v2.4になった後、バグが見つかりrevertされましたが、そのバグが修正され、高速化されたhttp-parserが使えるようになりました。

libuv が v1.4.2 になった

libuv が新しくなりました。 windows/linuxでのバグ修正や ARM でも動くようにするための修正などが含まれています。

npm が v2.9.0 になった

npm も新しくなりました。翻訳があるのでそこを見ておくと良いかもしれません。

medium.com


まとめ (v1.0 〜 v2.0の違い)

Streamを簡単に作れるようになった
LTTNG のサポート
Promise の unhandledRejection / rejectionHandled イベント
Buffer の indexOf メソッドを追加
node --require オプション追加
repl に history をsaveするモードが追加
v8 が新しくなり、 class, object リテラルの拡張 etcとStrong Mode が追加
ARMを初めとする バイナリの提供と幅広い環境のサポート
依存ライブラリの刷新による性能向上、バグ修正など
結び

さて、今回ざざっと v1.0 から今までの変更をお伝えしました。これらの変更は日本語の記事であれば、

blog.iojs.jp

にまとまっています*2。

変化の激しい io.js を追うのは大変ですが、この記事を毎週少しでも読んでおいてもらえると助けになると思います。
(毎週週末の時間を削って、翻訳している翻訳チームを助けてもらえるとありがたいです。)

また、コアチームは今は v3.0 に向けて動き出しています。僕もちょっとずつ改善を入れています。この変化を楽しみながら貢献できるといいなと思います。

*1:大津さんが書いてくれました。 大津さん ++

*2:いつも翻訳してくれる @watilde さん、 @jgs さん、 @kosamari さんに感謝です。
-->
